; QNet Node Configuration File
; version 1.1 - Updated for Activation Bridge and refined settings

[System]
log_level = INFO
debug = False
# max_workers = 4 
; (Handled by gunicorn or specific modules if needed, not a global AppConfig item typically)

[App]
name = QNet Node
version = 1.0.0

[Node]
node_id = qnode-${env:NODE_ID}
wallet_address = 
mining_enabled = True
node_type = full  # Options: light, full, super
max_tx_count_per_block = 1000
# mining_threads = 1 
; (Specific to old mining, consensus is now more event-driven)
max_pending_tx = 5000
min_fee = 0.0001 
; Minimum transaction fee for standard transactions
# mode = full 
; (This was in an old version, node.py doesn't use 'mode' directly from config)
# max_chain_length = 1000 
; (More of a conceptual limit or for pruning, not a direct operational config here)

[Network]
network_id = qnet-mainnet
external_ip = auto 
; 'auto' or specific IP. Can be set by QNET_EXTERNAL_IP env var.
port = 9876
api_port = 5000
dashboard_port = 5001 
; Port for a potential separate Flask-based dashboard/admin UI if not main API.
bootstrap_nodes = 127.0.0.1:9876,127.0.0.1:9877
max_peers = 50
min_peers = 3
discovery_interval = 300 
; Seconds for NodeDiscoveryManager periodic tasks
connection_timeout = 10 
; Seconds for outgoing P2P connection attempts
behind_proxy = false 
; Set to true if Flask app runs behind a reverse proxy like Nginx
# auto_discovery = true 
; (NodeDiscoveryManager is always active if used)
# use_upnp = false 
; (Specific to NodeDiscoveryManager config if implemented)
# use_broadcast = true 
; (Specific to NodeDiscoveryManager config if implemented)
# gossip_interval = 30 
; (Specific to P2P layer if implemented)
sync_interval = 120
# dns_seeds = 95.164.7.199,173.212.219.226 
; (Handled by NodeDiscoveryManager)

[Regional]
; Regional settings for geographic distribution
node_region = auto
; Options: auto, north_america, south_america, europe, africa, asia_pacific, middle_east, oceania
; Can also use shortcuts: na, sa, eu, af, ap, me, oc
; Or country codes: us, uk, de, jp, cn, au, etc.
; 'auto' will attempt to detect based on IP geolocation

prefer_regional_peers = true
; Prioritize connections to peers in the same or nearby regions

max_inter_regional_connections = 10
; Maximum connections to nodes outside your region

regional_latency_threshold_ms = 150
; Consider regions "nearby" if latency is below this threshold

enable_regional_sharding = true
; Enable regional optimization for transaction sharding

regional_backup_count = 2
; Number of backup regions to maintain connections with

[Storage]
storage_type = rocksdb
data_dir = data
# RocksDB specific (values from storage_config.py defaults, can be overridden here)
rocksdb_max_open_files = 300
rocksdb_write_buffer_mb = 64
rocksdb_max_write_buffers = 3
rocksdb_target_file_size_mb = 64
rocksdb_max_bg_compactions = 4
rocksdb_max_bg_flushes = 2
rocksdb_compression = lz4 ; lz4, zstd, snappy, or none
rocksdb_cache_mb = 128
# Memory specific (values from storage_config.py defaults)
memory_limit_mb = 512
memory_checkpoint_enabled = true
memory_checkpoint_interval = 3600 
; seconds
memory_checkpoint_dir = /app/snapshots 
; (can be same as general snapshots dir)
# Common
use_compression = true 
; General flag, can influence RocksDB or snapshot compression
block_cache_size_mb = 128 
; (Redundant with rocksdb_cache_mb, keep one or make distinct)
max_db_size_gb = 100
compression_enabled = True

[Paths]
keys_dir = keys

[Files]
peers_file = data/peers.json

[Consensus]
# Commit-Reveal base settings
commit_window_seconds = 60
reveal_window_seconds = 30
round_interval_seconds = 10
reputation_threshold = 0.5
min_participants = 3 
; Minimum nodes needed for a round to be considered for leader selection
min_reveals_ratio = 0.67 
; Minimum ratio of committers that must reveal for a round to proceed
# Dynamic Difficulty & Timing
target_round_time_seconds = 60
difficulty_adjustment_window = 10 
; Number of rounds to average for difficulty adjustment
max_difficulty = 1000.0 
; Max value for difficulty
# initial_reward = 16384 
; (This is hardcoded in block_rewards.py based on model)
# halving_interval = 10 
; (Emission is logarithmic, not halving based)

[Security]
; flask_secret_key must be set via environment variable FLASK_SECRET_KEY
; Never hardcode secret keys in configuration files!
# pq_algorithm = Dilithium2 
; (Handled by crypto modules, not a direct config toggle here for now)
# key_rotation_days = 90 
; (Concept for future implementation)
# tls_required = false 
; (For API, usually handled by reverse proxy like Nginx)
# validate_hostnames = true 
; (General security practice)
# sybil_resistance_enabled = true 
; (Conceptual, implemented via activation mechanism)
# database_key = 
; (For encrypting SQLite if used, not for RocksDB encryption here)
# did_registry = 
; (For future DID integration)
enable_post_quantum = True
signature_algorithm = dilithium3
encryption_algorithm = kyber1024
hash_algorithm = sha3-256

[Activation] ; Settings for the Activation Bridge and node activation
mock_solana_checks = false
; Set to true to bypass actual Solana checks for local dev
mock_issuer_signing = false
; Set to true to use mock issuer signature for local dev
mock_qnet_registry_checks = false
; Set true to bypass QNet registry checks for local dev

[Issuer] ; For Activation Token signing by the network operator/emitter
public_key_b58 = 8hiJmW8TB1ssJzBUC1Tr4NWergEggPE9DBfJv3VkLvZT

[Solana]
one_dev_mint = "62PPztDN8t6dAeh3FvxXfhkDJirpHZjGvCYdHM54FHHJ"
mint_authority = "6gesV5Dojg9tfH9TRytvXabnQT8U7oMbz5VKpTFi8rG4"
burn_address = "1nc1nerator11111111111111111111111111111111"
burn_contract = "D7g7mkL8o1YEex6ZgETJEQyyHV7uuUMvV3Fy3u83igJ7"
issuer_public_key = "8hiJmW8TB1ssJzBUC1Tr4NWergEggPE9DBfJv3VkLvZT"
rpc_url = "https://api.devnet.solana.com"
commitment = "confirmed"

# Bridge monitoring
check_interval_seconds = 30
confirmation_blocks = 32

# Burn verification
minimum_burn_confirmations = 64
verify_burn_signature = true

[Token] ; For 1DEV and QNC token details used in activation
dev_mint_address = 62PPztDN8t6dAeh3FvxXfhkDJirpHZjGvCYdHM54FHHJ
; 1DEV token mint for Phase 1 - PRODUCTION READY
; Created: 2025-01-14 with 1 billion token supply
; MINT AUTHORITY: 6gesV5Dojg9tfH9TRytvXabnQT8U7oMbz5VKpTFi8rG4
; Faucet: Full supply available for node activation
dev_decimal_places = 6
dev_total_supply = 1000000000  ; 1 billion 1DEV tokens
; Phase 1: 1DEV burn amounts (with 6 decimals) - BURN-TO-JOIN
dev_burn_light = 1500000000    ; 1,500 1DEV to burn for light node
dev_burn_full = 1500000000     ; 1,500 1DEV to burn for full node  
dev_burn_super = 1500000000    ; 1,500 1DEV to burn for super node
; Minimum burn amounts after 90% supply burned
dev_min_burn_light = 150000000    ; 150 1DEV minimum (90% reduction)
dev_min_burn_full = 150000000     ; 150 1DEV minimum (90% reduction)
dev_min_burn_super = 150000000    ; 150 1DEV minimum (90% reduction)

; Phase 1: 1DEV burn amounts (alternative naming)
onedev_initial_burn_light = 1500000000  ; 1500 1DEV (6 decimals)
onedev_initial_burn_full = 1500000000   ; 1500 1DEV (6 decimals) 
onedev_initial_burn_super = 1500000000  ; 1500 1DEV (6 decimals)
onedev_min_burn_light = 150000000       ; 150 1DEV minimum
onedev_min_burn_full = 150000000        ; 150 1DEV minimum
onedev_min_burn_super = 150000000       ; 150 1DEV minimum

; Phase 2: QNC spending amounts (with 6 decimals) - SPEND TO POOL 3
qnc_spend_light = 5000.000000  ; Light node QNC spend requirement
qnc_spend_full = 7500.000000   ; Full node QNC spend requirement  
qnc_spend_super = 10000.000000 ; Super node QNC spend requirement

; Pool 3 Redistribution from QNC spending
pool3_spend_distribution = true  ; Enable Pool 3 redistribution
pool3_all_nodes_benefit = true   ; All node types receive Pool 3 rewards

# Phase 2: QNC spending amounts for activation (SPEND TO POOL 3)
QNC_SPEND_LIGHT = 5000
QNC_SPEND_FULL = 7500
QNC_SPEND_SUPER = 10000

# Pool 3 Redistribution
POOL3_ENABLED = true
POOL3_REDISTRIBUTION = true

[Reputation] ; Settings for ReputationConsensusManager (0-100 scale)
default_reputation = 70.0
initial_reputation = 70.0
max_reputation = 100.0
min_reputation = 0.0
rewards_threshold = 40.0
consensus_threshold = 70.0
ban_threshold = 10.0
history_size = 100
min_data_points = 5
weight_participation = 0.4
weight_response_time = 0.3
weight_block_quality = 0.3
decay_factor = 0.95
penalty_invalid_reveal = 20.0
penalty_mining_failure = 10.0
reward_participation = 5.0
reward_leader = 10.0
regression_factor = 0.95 
; How much to regress towards default_reputation
smoothing_factor = 0.2 
; For EMA of reputation score

[EnhancedConsensus] ; Settings for AdaptiveConsensusTimer and other advanced features
# enabled = true 
; (Activation logic for this can be more dynamic)
reputation_influence = 0.7 
; How much reputation affects leader selection (0.0 to 1.0)
adaptive_timing = true 
; Enable adaptive commit/reveal windows
safety_factor = 1.5 
; Multiplier for calculated optimal windows for robustness
# partition_detection = true 
; (NetworkPartitionManager specific, usually enabled by its presence)
# detection_interval = 300 
; (NetworkPartitionManager specific)
# recovery_cooldown = 600 
; (NetworkPartitionManager specific)

[ConsensusMetrics] ; Settings for NetworkMetrics class used by AdaptiveConsensusTimer
window_size = 100 
; Number of data points for rolling averages in NetworkMetrics
update_interval = 5 
; Seconds between NetworkMetrics recalculations
latency_weight = 0.3
throughput_weight = 0.3
success_rate_weight = 0.4

[Monitoring] ; Settings for node/monitoring.py
enabled = true
metrics_interval_seconds = 10
prometheus_enabled = True
prometheus_port = 9090
# webhook_url = YOUR_ALERT_WEBHOOK_URL 
; For sending alerts
enable_metrics = True
metrics_port = 9090
enable_prometheus = True
enable_grafana_dashboard = True

[Sync] ; Settings for sync_manager.py
sync_mode = full 
; 'full' or 'fast' (fast sync might use snapshots)
checkpoint_verification = true
max_parallel_downloads = 5
fast_sync_threshold = 1000 
; Block difference to trigger fast sync
sync_batch_size = 100 
; General batch size for sync operations
headers_batch_size = 500 
; For syncing block headers
blocks_batch_size = 50 
; For syncing full blocks
# trusted_checkpoints = 0:GENESIS_HASH,10000:ANOTHER_HASH 
; Comma-separated height:hash

[Snapshots] ; Settings for blockchain state snapshots (used by storage and potentially fast sync)
auto_snapshot_enabled = true 
; If storage manager should auto-create snapshots
retention_days = 7
min_keep_count = 3
cleanup_frequency_sec = 86400 
; How often to check for old snapshots to delete

[Checkpoints] ; For trusted blockchain checkpoints (different from state snapshots)
auto_create_enabled = true 
; If SyncManager should create local checkpoints
creation_interval_blocks = 1000
check_frequency_sec = 3600

; [Authentication] ; (This section was from token_verification_api.py, merging relevant parts)
; verification_enabled = true
; test_mode = true
; wallet_address = SET_VIA_ENVIRONMENT_VARIABLE

; [DDoS] ; (Rate limiting is now handled by rate_limiter.py, not directly via these old config keys)
; request_limit = 100
; time_window = 60
; block_time = 300
; whitelist = 127.0.0.1,172.17.0.0/16,95.164.7.199,173.212.219.226

[SmartContracts]
vm_enabled = True
max_contract_size_kb = 1024
max_gas_per_block = 10000000
gas_price_qnc = 0.0001
wasm_optimization_level = 2
contract_storage_limit_mb = 100

[Performance]
enable_rust_optimization = True
enable_go_networking = True
parallel_validation_threads = 4
transaction_pool_size = 10000
block_cache_size = 1000

[NodeActivation]
# Phase 1: 1DEV burn amounts for activation (BURN-TO-JOIN)
dev_burn_light = 1500       # 1DEV to burn for light node
dev_burn_full = 1500        # 1DEV to burn for full node  
dev_burn_super = 1500       # 1DEV to burn for super node

# Phase 2: QNC spending amounts for activation (SPEND TO POOL 3)
qnc_spend_light = 5000       # QNC to spend for light node
qnc_spend_full = 7500        # QNC to spend for full node  
qnc_spend_super = 10000      # QNC to spend for super node

# Ping-based reward system (CORRECT: NETWORK PINGS NODES!)
# Network randomly pings nodes in 4-hour window using assigned slots
reward_window_hours = 4          # Rewards distributed every 4 hours
ping_slots_per_window = 240      # 240 slots (1 minute each) in 4-hour window
ping_timeout_seconds = 60        # 60 seconds to respond to network ping
ping_success_rate = 0.90         # 90% expected success rate
missed_ping_penalty = 0          # Just lose reward for that period

# Randomized slot assignment (deterministic per node_id)
enable_ping_randomization = True
max_ping_load_per_second = 1000  # Maximum network load target

# Node-type specific ping priorities 
super_node_priority_slots = 24   # Super nodes use first 24 slots (10x more frequent)
full_node_slots = 240           # Full nodes use all 240 slots  
light_node_slots = 240          # Light nodes use all 240 slots

# Network connectivity requirements
ping_response_timeout = 60       # 60 seconds to respond when pinged
network_retry_attempts = 3       # Retry failed pings up to 3 times
offline_grace_period = 300       # 5 minutes grace for network issues
max_devices_per_node = 3         # Maximum devices per wallet/node

[NodeRewards]
# Base reward pool (distributed every 4 hours)
base_reward_pool = 245100.67   # QNC per 4-hour period
reward_distribution_hours = 4   # Every 4 hours

# Transaction fee distribution
full_node_fee_share = 0.30     # 30% of fees
super_node_fee_share = 0.70    # 70% of fees
light_node_fee_share = 0.00    # 0% of fees

# Minimum hardware (for guidance only)
light_node_min_ram_gb = 1
full_node_min_ram_gb = 4  
super_node_min_ram_gb = 16

[MobileOptimization]
enable_mobile_mode = True
# Mobile nodes use 8-hour ping window (defined in NodeActivation section)
mobile_push_notifications = True
mobile_battery_saver = True
mobile_data_compression = True
# Push notification settings
push_notification_rate_limit = 10  # Max 10 notifications per hour per node
push_cleanup_days = 30  # Clean old tokens after 30 days

[Development]
enable_test_mode = False
test_network_delay_ms = 0
test_packet_loss_percent = 0
enable_debug_endpoints = True

[DAO]
# DAO Governance Settings - DELAYED IMPLEMENTATION
dao_enabled = false
governance_mode = centralized
dao_launch_year = 2026
dao_manual_activation_required = true
dao_testnet_enabled = true

# UI Features (disabled in production until DAO launch)
ui_dao_section = false
ui_governance_voting = false
ui_proposal_creation = false
ui_dao_dashboard = false

# Future DAO parameters (ready for activation)
min_proposal_stake_qnc = 1000
voting_period_days = 7
discussion_period_days = 14
quorum_percentage = 5
emergency_quorum_percentage = 25

# Progressive unlock system (3-year plan)
year1_governance = emergency_only
year2_governance = emergency_and_community
year3_governance = full_governance

# Multisig configuration (for future use)
multisig_threshold = 5
multisig_total_members = 7
founder_veto_period_months = 9
