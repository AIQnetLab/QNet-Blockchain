#!/usr/bin/env node

/**
 * QNet DAO GitHub Integration
 * Syncs GitHub Issues with DAO proposals on vote.qnet.org
 */

const { Octokit } = require('@octokit/rest');
const axios = require('axios');

class DAOGitHubSync {
  constructor() {
    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN
    });
    
    this.config = {
      owner: 'qnet-project',
      repo: 'dao-proposals',
      votingApiUrl: process.env.VOTING_API_URL || 'https://vote.qnet.org/api',
      webhookSecret: process.env.WEBHOOK_SECRET
    };
  }

  /**
   * Parse GitHub Issue to extract DAO proposal data
   */
  parseIssueToProposal(issue) {
    const body = issue.body || '';
    const title = issue.title;
    
    // Extract proposal type from labels
    const typeLabel = issue.labels.find(label => 
      ['emergency', 'community', 'economic', 'technical', 'critical'].includes(label.name)
    );
    
    const proposalType = typeLabel ? typeLabel.name : 'community';
    
    // Extract structured data from issue body
    const descriptionMatch = body.match(/## Description\s*\n([\s\S]*?)(?=\n##|$)/);
    const description = descriptionMatch ? descriptionMatch[1].trim() : body;
    
    const amountMatch = body.match(/## Amount\s*\n([\s\S]*?)(?=\n##|$)/);
    const amount = amountMatch ? amountMatch[1].trim() : null;
    
    return {
      title,
      description,
      type: proposalType,
      amount,
      githubIssue: issue.number,
      author: issue.user.login,
      created: issue.created_at
    };
  }

  /**
   * Sync GitHub Issue to voting platform
   */
  async syncIssueToVoting(issue) {
    try {
      const proposal = this.parseIssueToProposal(issue);
      
      // Check if proposal already exists
      const existingProposal = await this.findProposalByGitHubIssue(issue.number);
      
      if (existingProposal) {
        console.log(`Proposal for issue #${issue.number} already exists`);
        return existingProposal;
      }
      
      // Create new proposal on voting platform
      const response = await axios.post(`${this.config.votingApiUrl}/proposals`, {
        ...proposal,
        source: 'github'
      });
      
      if (response.data.success) {
        // Add comment to GitHub issue with voting link
        await this.addVotingLinkComment(issue.number, response.data.proposal.id);
        
        // Add label to indicate sync
        await this.octokit.issues.addLabels({
          owner: this.config.owner,
          repo: this.config.repo,
          issue_number: issue.number,
          labels: ['dao-synced']
        });
        
        console.log(`Successfully synced issue #${issue.number} to voting platform`);
        return response.data.proposal;
      }
    } catch (error) {
      console.error(`Failed to sync issue #${issue.number}:`, error.message);
      
      // Add error comment to GitHub
      await this.addErrorComment(issue.number, error.message);
    }
  }

  /**
   * Find existing proposal by GitHub issue number
   */
  async findProposalByGitHubIssue(issueNumber) {
    try {
      const response = await axios.get(`${this.config.votingApiUrl}/proposals`, {
        params: { githubIssue: issueNumber }
      });
      
      return response.data.proposals.find(p => p.githubIssue === issueNumber);
    } catch (error) {
      console.error('Failed to check existing proposals:', error.message);
      return null;
    }
  }

  /**
   * Add voting link comment to GitHub issue
   */
  async addVotingLinkComment(issueNumber, proposalId) {
    const comment = `🗳️ **DAO Proposal Created**

This GitHub issue has been automatically synced to the QNet DAO voting platform.

**Vote on this proposal:** https://vote.qnet.org/proposals/${proposalId}

**Proposal ID:** ${proposalId}

---
*This comment was automatically generated by the QNet DAO GitHub integration.*`;

    await this.octokit.issues.createComment({
      owner: this.config.owner,
      repo: this.config.repo,
      issue_number: issueNumber,
      body: comment
    });
  }

  /**
   * Add error comment to GitHub issue
   */
  async addErrorComment(issueNumber, errorMessage) {
    const comment = `❌ **DAO Sync Failed**

Failed to sync this issue to the DAO voting platform.

**Error:** ${errorMessage}

Please check the issue format and try again, or contact the development team.

---
*This comment was automatically generated by the QNet DAO GitHub integration.*`;

    await this.octokit.issues.createComment({
      owner: this.config.owner,
      repo: this.config.repo,
      issue_number: issueNumber,
      body: comment
    });
  }

  /**
   * Update GitHub issue with voting results
   */
  async updateIssueWithResults(proposalId, results) {
    try {
      // Find GitHub issue by proposal ID
      const proposal = await this.findProposalById(proposalId);
      if (!proposal || !proposal.githubIssue) {
        console.log(`No GitHub issue found for proposal ${proposalId}`);
        return;
      }

      const comment = `📊 **Voting Results**

**Status:** ${results.status}
**Votes For:** ${results.votesFor.toLocaleString()} QNC
**Votes Against:** ${results.votesAgainst.toLocaleString()} QNC
**Quorum:** ${results.quorumMet ? '✅ Met' : '❌ Not met'} (${results.quorumRequired.toLocaleString()} QNC required)
**Participation:** ${results.participationRate}%

${results.status === 'passed' ? '✅ **Proposal Passed**' : '❌ **Proposal Failed**'}

---
*Voting results updated automatically from the QNet DAO platform.*`;

      await this.octokit.issues.createComment({
        owner: this.config.owner,
        repo: this.config.repo,
        issue_number: proposal.githubIssue,
        body: comment
      });

      // Close issue if proposal passed or failed
      if (results.status === 'passed' || results.status === 'failed') {
        await this.octokit.issues.update({
          owner: this.config.owner,
          repo: this.config.repo,
          issue_number: proposal.githubIssue,
          state: 'closed'
        });
      }

    } catch (error) {
      console.error(`Failed to update issue for proposal ${proposalId}:`, error.message);
    }
  }

  /**
   * Find proposal by ID
   */
  async findProposalById(proposalId) {
    try {
      const response = await axios.get(`${this.config.votingApiUrl}/proposals/${proposalId}`);
      return response.data.proposal;
    } catch (error) {
      console.error(`Failed to find proposal ${proposalId}:`, error.message);
      return null;
    }
  }

  /**
   * Process webhook from GitHub
   */
  async processWebhook(payload) {
    const { action, issue } = payload;

    // Only process issues with DAO proposal labels
    const hasDAOLabel = issue.labels.some(label => 
      ['dao-proposal', 'emergency', 'community', 'economic', 'technical', 'critical'].includes(label.name)
    );

    if (!hasDAOLabel) {
      console.log(`Issue #${issue.number} doesn't have DAO labels, skipping`);
      return;
    }

    switch (action) {
      case 'opened':
        console.log(`New DAO proposal issue opened: #${issue.number}`);
        await this.syncIssueToVoting(issue);
        break;
        
      case 'edited':
        console.log(`DAO proposal issue edited: #${issue.number}`);
        // TODO: Update existing proposal
        break;
        
      case 'closed':
        console.log(`DAO proposal issue closed: #${issue.number}`);
        // TODO: Handle issue closure
        break;
        
      default:
        console.log(`Unhandled action: ${action} for issue #${issue.number}`);
    }
  }

  /**
   * Sync all existing DAO proposal issues
   */
  async syncAllIssues() {
    try {
      console.log('Syncing all existing DAO proposal issues...');
      
      const { data: issues } = await this.octokit.issues.listForRepo({
        owner: this.config.owner,
        repo: this.config.repo,
        labels: 'dao-proposal',
        state: 'open'
      });

      console.log(`Found ${issues.length} DAO proposal issues`);

      for (const issue of issues) {
        await this.syncIssueToVoting(issue);
        // Add delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      console.log('Sync completed');
    } catch (error) {
      console.error('Failed to sync all issues:', error.message);
    }
  }
}

// CLI interface
if (require.main === module) {
  const sync = new DAOGitHubSync();
  
  const command = process.argv[2];
  
  switch (command) {
    case 'sync-all':
      sync.syncAllIssues();
      break;
      
    case 'webhook':
      // For webhook server implementation
      console.log('Webhook server not implemented in this script');
      console.log('Use this class in your webhook server');
      break;
      
    default:
      console.log('Usage:');
      console.log('  node proposal-sync.js sync-all    # Sync all existing issues');
      console.log('  node proposal-sync.js webhook     # Info about webhook usage');
  }
}

module.exports = DAOGitHubSync; 